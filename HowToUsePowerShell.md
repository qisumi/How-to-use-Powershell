# How to use Powershell

## 基本概念

### Cmdlet

Cmdlet是PowerShell环境中实现功能的特殊命令。遵循“动词-名词”模式，例如：`set-childItem`。Cmdlet的输入输出都是对象，而且通过管道输入和输出。Cmdlet处理对象序列和集合时是线性的，同时只处理一个。一些Cmdlet拥有缩写，通常是再Linux中有相同功能的命令。

### 与Linux Shell的不同

PowerShell大部分情况下处理的都是对象。而Linux Shell只处理文本。相对应的，Linux Shell的内置命令的输入输出也都是文本。	

### 基本术语

1. 别名：将较长的命令赋予较短的别名

2. 环境变量：从操作系统环境中获取变量，例如 `$PATH`.

3. 函数：Powershell脚本中可以创建并使用函数

4. 变量：Powershell脚本中可以定义并使用变量

5. 工作位置：在调用命令时，如果没有显示指定路径，往往使用工作位置的路径

6. 项：包括别名、变量、函数、环境变量、或者文件和目录。

7. 路径名：包括绝对路径、相对路径、特殊路径。绝对路径一般是从`C:/`或者`D:/`开始（Linux上则从`/`开始。相对路径相对于工作位置开始。特殊路径见对应章节。

8. 模块：模块作为一个脚本，可以导出变量和函数，供其他脚本或者shell导入使用。

9. 重载和调用解析：函数名相同但函数签名[^1]不同的函数。PowerShell和大多数支持重载的编程语言一样，会自动按照参数解析。

10. 管道：管道是由管道运算符 `|`分隔的一个或多个命令序列，每个命令接受前置任务的输入，并将输出写入到后续任务。管道末尾处的输出默认会输出到控制台，也可以重定向到文件。

    [^1]: 函数签名：函数名称、参数数量、参数类型统一构成了函数签名

### 通配符表达式

Powershell除了支持正则表达式，也在一些地方支持简单通配符，规则如下：

|          元素          |                             描述                             |
| :--------------------: | :----------------------------------------------------------: |
| 除*、? 和 [ 之外的字符 |                         匹配一个字符                         |
|           *            |     与零个或多个字符匹配。 若要匹配 * 字符，请使用 [*]。     |
|           ?            |        匹配任何单字符。 如需匹配 ? 字符，请使用 [?]。        |
|         [set]          | 匹配 set 中的任意一个字符，不能为空如果 set 以 ] 开头，则右方括号被视为 set 的一部分，下一个右方括号终止 set；否则，第一个右方括号终止 set。如果 set 以 - 开头或结尾，则减号连字符被视为 set 的一部分；否则，它指示一系列连续的 Unicode 代码点，连字符减号两边的字符开始包含在内的范围分隔符。 例如，A-Z 指示 26 个大写英文字母，0-9 指示 10 个十进制数字。 |

### 特殊路径名

对于相对路径，有如下规则：

| 符号 | 说明                   | 相对路径           | 完全限定的路径      |
| :--- | :--------------------- | :----------------- | :------------------ |
| `.`  | 当前工作位置           | `.\System`         | `C:\Windows\System` |
| `..` | 当前工作位置的父级     | `..\Program Files` | `C:\Program Files`  |
| `\`  | 当前工作位置的驱动器根 | `\Program Files`   | `C:\Program Files`  |
| 无   | 无特殊字符             | `System`           | `C:\Windows\System` |

## 变量

### 变量基础

变量以`$`开头，不区分大小写，不包含空格和特殊字符。默认情况下变量的值为`$NULL`。特别的，如果需要在变量名称中使用特殊字符，需要将变量名置于大括号中，例如`{my-variable}`。

变量使用`=`赋值，使用`Clear-Variable`删除变量，也可以将其赋值为`$null`。

对于变量的类型，可以使用`GetType()`方法查看。

默认创建的变量都是局部变量，如果需要创建特殊的变量遵循以下规则：`$global: var`创建全局变量。`$script: var`创建脚本变量。

变量根据用户能否修改、由谁创建分为三种。

|    类型    | 创建者 | 用户读写 |
| :--------: | :----: | :------: |
|  用户变量  |  用户  |   读写   |
|  自动变量  |  系统  |   只读   |
| 首选项变量 |  系统  |   读写   |

### 可变修饰符

1. ReadOnly 可访问，不可修改，可删除
2. Constant 可访问，不可修改，不可删除

### 自动变量

自动变量由系统创建和维护，用户可读不可写。常见的自动变量有：

|              变量               |                      描述                      |
| :-----------------------------: | :--------------------------------------------: |
|               $$                |          最后执行的命令中的最后一部分          |
|               $?                |          最后一个操作执行状态是否成功          |
|               $_                |     在管道对象集合的遍历语法中表示当前对象     |
|            $foreach             |            表示ForEach循环的枚举数             |
|      \$true \$false \$null      |                表示布尔值和空值                |
| \$IsLinux \$IsWindows \$IsMacOS |                    查询平台                    |
|             $input              | 枚举传递给函数的所有输入，仅适用于脚本快和功能 |
|              $Home              |                 用户的Home目录                 |

### 首选项变量

常见的首选项变量有

|         变量         |      默认值      |
| :------------------: | :--------------: |
|   $OutputEncoding    | UTF8Encoding对象 |
| $MaximumHistoryCount |       4096       |

## 运算符

任何列出而不加说明的运算符，其作用和常见编程语言中的类似。

> 在 PowerShell 中存在两种运算符，一种使用符号表达，例如 + - * / 。而另外一种是使用单词来表达运算。这样做的好处是可以避免符号不够用的情况，这些运算符的使用方式为 `-op`。以 `eq`为例：`$a -eq $b`.表示 `a==b`

### 算术运算符

`+` `-` `*` `/` `%` `++` `--`

> 特别说明：这里的乘法运算符还用于数组、字符串的复制。加法用于字符串、数组、哈希表的连接

### 比较运算符

`eq` `ne` `gt` `ge` `lt` `le`

> 特别说明：PowerShell 允许一个集合和一个操作数进行比较。但返回的不是一个布尔数组，而是返回集合的子集，其中的项满足在比较中返回了 `$True`

这是一种常用，但是又不太常用的运算符表达方式，如果你熟悉Latex应该会比较熟悉。其简要含义包括：

1. `eq -> equal` 等于

2. `ne -> not equal` 不等于

3. `gt -> greater than, lt -> less then` 大于或小于

4. `ge -> great equal, lt -> less equal` 大于等于或小于等于

### 赋值运算符

`=` `+=` `-=` `*=` `\=`

### 逻辑运算符

`AND` `OR` `NOT` `XOR`

### 位运算符

`BAND` `BOR` `BXOR`

### 一些用于字符串的运算符

   1. `not` 前缀表示否定
   2. `c` 前缀表示大小写敏感（对非字符串运算不起作用）
   3. `i` 前缀表示显示大小写不敏感（对非字符串运算不起作用）

   ```
       -as           -ccontains     -ceq
       -cge          -cgt           -cle
       -clike        -clt           -cmatch
       -cne          -cnotcontains  -cnotlike
       -cnotmatch    -contains      -creplace
       -csplit       -eq            -ge
       -gt           -icontains     -ieq
       -ige          -igt           -ile
       -ilike        -ilt           -imatch
       -in           -ine           -inotcontains
       -inotlike     -inotmatch     -ireplace
       -is           -isnot         -isplit
       -join         -le            -like
       -lt           -match         -ne
       -notcontains  -notin         -notlike
       -notmatch     -replace       -shl
       -shr          -split
   ```

### 其他运算符

1. 管道运算符：`|`

2. 输出重定向运算符：`>` `>>` 

3. 调用、属性访问运算符：`.`

4. 逗号运算符（用于创建数组）：`,`

5. 字符串操作运算符：`split` `join` `replace` 及其前缀变体

6. 强制类型转换运算符：`[type]`

7. 范围运算符（生成一维数组）：`..` 例如 `1..3`表示`1,2,3`

8. 字符串格式化运算符：`{N[,M][:FormatString]}`

9. 包含运算符：`contains` `in` 及其 `not` 前缀变体。他们的区别在于语义，对于`contains`数组为左操作数，对于`in`则相反。

10. 类型测试运算符 ：`is`

11. 模式匹配运算符：`match` `like` 及其前缀变体。其中`match`支持正则表达式，而`like`支持通配符表达式。

    > 对于 match 和 replace 这种可以接受正则表达式的函数来说，还支持子表达式，在返回的结果中按照顺序（从0开始，按左括号出现的顺序）来排列。对于 replace 来说，使用 $1 \$2 来表达。也可以使用?<name>来定义具名匹配项而不是让 \$matches 中的键成为从0开始的索引

## 表达式

表达式是一系列运算符和操作数，它指定方法、函数、可写位置或值；指定值的计算；产生一个或多个副作用；或执行它们的某种组合。例如

- 文本 123 是一个指定 int 值 123 的表达式。

- 表达式 `1,2,3,4` 指定具有所示值的 4 元素数组对象。

- 表达式 `10.4 * $a` 指定计算。

- 表达式 `$a++` 会产生副作用。

- 表达式 `$a[$i--] = $b[++$j]` 执行这些操作的组合。

在PowerShell的表达式中，运算优先级和其他编程语言没有明显区别，包括使用括号改变优先级，不做更多介绍。

> 顶级表达式的值可能会被自动放入管道。如果某个**顶级表达式**包含副作用运算符（例如赋值、自增自减运算符），那么其值不会被放入管道，反之则会。顶级表达式指不属于某个更大表达式的表达式。可以使用括号强制将一个顶级表达式变为非顶级表达式，例如`($a++)`是一个非顶级表达式

### 调用表达式

调用表达式通过`.`或者`::`来完成。例如

```powershell
[math]::Sqrt(2.0)
[char]::IsUpper("a")
$b.ToUpper()
```

> 这里有一种特殊的语法，`[math]::Sqrt` 这实际上是因为PowerShell受`.Net`支持，所以也可以使用`.Net`中的很多特性。

### $(...)表达式

对内部语句列表（使用`;`分割）分别求值，如果得到单个元素，则结果为该元素。没有结果则为 `$null`。否则则为对象数组。并将结果作为一个对象数组写入管道。

```powershell
$j = 20
$($i = 10) # pipeline gets nothing
$(($i = 10)) # pipeline gets int 10
$($i = 10; $j) # pipeline gets int 20
$(($i = 10); $j) # pipeline gets [object[]](10,20)
$(($i = 10); ++$j) # pipeline gets int 10
$(($i = 10); (++$j)) # pipeline gets [object[]](10,22)
$($i = 10; ++$j) # pipeline gets nothing
$(2,4,6) # pipeline gets [object[]](2,4,6)

$a = @(2,4,6)          # result is array of 3
@($a)                  # result is the same array of 3
@(@($a))               # result is the same array of 3
```

### @(...)表达式

与`$(,,,)`表达式类似。区别在于，在没有值时，`@(...)`会得到一个空数组，而`$(...)`会得到`$null`.

### @{...}表达式

用于创建哈希表，详见相关章节。

## 命令

### 命令调用

命令调用包含命令的名称和若干个自变量（参数），合法的命令可以是：

1. 别名
2. 函数
3. cmdlet
4. 外部命令

对于重名的命令，也按照上述顺序（优先级）进行查找。

对于命令调用，也有另外一种方式，它允许我们使用字符串来调用。这样我们就可以把命令储存到变量中，例如以下三种调用是等价的。
```powershell
Get-Factorial 5
& Get-Factorial 5
& "Get-Factorial" 5
```

> 和大多数编程语言类似，如果一个命令是函数，那么它支持直接或间接的 **递归 **调用

### 命令参数

调用命令时可以输入若干变量作为参数，参数名以`-`开头，并且后面紧随若干空白符，再绑定一个参数值。常见命令参数有以下三种形式：

- 开关参数：参数的类型为布尔值。

  ```powershell
  Set-MyProcess -Strict
  Set-MyProcess -Strict: $true
  ```

- 普通参数

  ```
  Get-Power -base 5 -exponent 3
  Get-Power -exponent 3 -base 5
  ```

- 位置参数

  ```powershell
  Get-Power 5 3
  ```

- [通用参数](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_commonparameters)：指可以和任何 cmdlet 一起使用的参数。

### 错误处理

命令失败时，将被视为错误，关于错误的信息记录在错误记录中，其类型未指定。

错误属于两个类别之一。 它要么终止运算（终止错误），要么不终止运算（非终止错误）。 对于终止错误，系统会记录错误并停止运算。 对于非终止错误，系统会记录错误并继续运算。

自动变量 `$Error` 包含一组表示最近错误的错误记录，最近的错误在 `$Error[0]` 中。 此集合保留在缓冲区中，这样在添加新记录时会放弃旧记录。 自动变量 `$MaximumErrorCount` 控制可存储的记录数。

`$Error` 包含在同一个集合中混合在一起的所有命令中的所有错误。 若要从特定命令中收集错误，请使用常用参数 `ErrorVariable`，该参数允许指定用户定义的变量来保存集合。

## 管道

管道是由管道运算符 `|`分隔的一个或多个命令序列，每个命令接受前置任务的输入，并将输出写入到后续任务。管道末尾处的输出默认会输出到控制台，也可以重定向到文件。

### 管道语句

管道语句是使用`|`连接的若干个命令或表达式。PowerShell会用如下规则处理这些自变量作为命令的参数。

- 如果不是表达式，担保函任意文本，没有空格，视为保留大小写的字符串。
- 如果使用引号包裹，则视为包含空格的字符串
- 用括号包裹自变量会导致计算该表达式的值
- 如果是参数则进行对应的参数解析

### 管道的流式处理

如果某个命令写入一个对象，则它的后续任务会接收该对象，然后在将其自己的对象写入到其后续对象之后终止。 但是，如果一个命令写入多个对象，则每次将一个对象传递到后续任务命令，该命令对每个对象执行一次。 此行为称为流式处理。 在流处理过程中，对象会在可用时立即写入管道，而不是在整个集合生成后。

## 字符串

Powershell中的字符串可以由单引号或双引号定义。他们都是`System.String`对象（来自`.Net`平台）。

### 字符串常用操作

```powershell
# 串联的三种方法
$s1+$s2
$s1,$s2 -join ".COM" # 输出{$s1}.COM{$s2}
[System.String]::Concat($s1,$s2)
#子串
$s.SubString(begin,len)
# 格式化内插
$s = "{0:n2,10} {1:p1,-10}" -f $s1,$s2 # :n2表示保留2位小数 :p1先保留小数点后一位再转换为百分数，,10 ,-10表示向右(左)对齐并补足10位。
# 替换
$s.Replace(s1,s2) 
$s -replace s1,s2 # 大小写不敏感，使用creplace则大小写敏感
$s -creplace s1,s2
# 包含
$s. -match $s1 # 大小写不敏感, 使用cmatch则大小写敏感
$s.Contains($s1) # 大小写敏感
# 过滤器
$s -like "3.14*" # -like支持通配符
# 分割
$s.Split($s1,[StringSplitOptions]::RemoveEmptyEntries) # 指定删除空的切割结果
# 比较
$s1.CompareTo($s1)
# 长度
$s.Length
# 插入
$s.Insert(begin, $s1)
# 删除
$s.Remove(begin, length)
# join
"10","20","30" -join(",") # 10,20,30
```

### 字符串格式化

```powershell
# 字符串格式化的详细规则
`$i` = 10; $j = 12
"{2} <= {0} + {1}\`n" -f $i,$j,($i+$j)  # 22 <= 10 + 12
">{0,3}<" -f 5                          # > 5<
">{0,-3}<" -f 5                         # >5 <
">{0,3:000}<" -f 5                      # >005<
">{0,5:0.00}<" -f 5.0                   # > 5.00<
">{0:C}<" -f 1234567.888                # >$1,234,567.89<
">{0:C}<" -f -1234.56                   # >($1,234.56)<
">{0,12:e2}<" -f 123.456e2              # > 1.23e+004<
">{0,-12:p}<" -f -0.252                 # >-25.20 % <
$format = ">{0:x8}<"
$format -f 123455                       # >0001e23f<
```

## 语句

### 语句块

和`C/C++` `JAVA`类似，PowerShell使用`{...}`来表示语句块，一个语句块内可以有若干语句。类似`JavaScript`，PowerShell不强制使用`;`作为语句分隔符。

### 语句的值

语句的值是它写入管道的一组累计值。 如果语句写入一个标量值，则该值是语句的值。 如果语句写入多个值，则该语句的值是一组按写入顺序存储在不受约束的一维数组的元素中的值。

```powershell
# 循环没有迭代，也没有向管道写入任何内容。 语句的值为 $null。
$v = for ($i = 10; $i -le 5; ++$i) { }

# 循环迭代了五次，但没有向管道写入任何内容。 语句的值为 $null。
$v = for ($i = 1; $i -le 5; ++$i) { }

# 循环迭代了五次，每次向管道写入 int 值 $i。 语句的值是值为 Length 5 的 object[]。
$v = for ($i = 1; $i -le 5; ++$i) { $i }
```



### 标记语句

和大多数编程编程语言不同的是，PowerShell的`break/continue`可以根据标记跳出若干层循环。这是一个非常好的特性。就像下面这样使用：

```powershell
:go_here while ($j -le 100) {
    # ...
}

:labelA
for ($i = 1; $i -le 5; ++$i) {
    :labelB
    for ($j = 1; $j -le 3; ++$j) {
        :labelC
        for ($k = 1; $k -le 2; ++$k) {
            # ...
        }
    }
}
```



> 实际上，对设计良好的代码，我们不应该需要这个特性，如果我们的代码中有多层循环，并且还有复杂的`break`需求，说明我们需要修改代码的设计，但是有总比没有好。

### IF语句

和大多数语言类似的设计，包含 `if` `elseif` `else` 三个关键字。

### WHILE，DO WHILE语句

和大多数语言类似的设计。

### FOR语句

和大多数语言类似的设计。

### FOREACH语句

通常和 `in` 搭配使用。可遍历对象包括：

- 数组
- 范围
- 数组字面量
- 管道输出的对象集合
- 集合的`Keys` `Values`

示例：

```powershell
# 数组
foreach ($e in $a) {
    ...
}
# 范围
foreach ($e in -5..5) {
    ...
}
# 数组字面量
foreach ($t in [byte], [int], [long]) {
    $t::MaxValue # get static property
}
# 管道的输出
foreach ($f in Get-ChildItem *.txt) {
    ...
}
# 集合的Keys或Values
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
foreach ($e in $h1.Keys) {
    "Key is " + $e + ", Value is " + $h1[$e]
}
```

### 流程控制语句

以下语句和其他语言的设计类似，但有一些区别

- `break` （可以使用标签）
- `continue` （可以使用标签）
- `exit $code`（终止当前脚本）
- `switch default` （可以使用字符串作为值，甚至可以使用正则表达式，不需要使用显性的`break`）

### 异常处理语句

`try` `catch` `finally` `thorw` 和其它语言的设计类似

## 数组

在PowerShell中声明数组，使用逗号分割的多个值给变量赋值。默认情况下数组是多态数组，不要求元素具有相同的类型。*同时，PowerShell中的类型是引用类型，这意味着简单的赋值不会创建新的对象。*

`$var = v1, v2, v3,...,vn`

在PowerSehll中访问数组元素，使用方括号，下标从`0`开始，支持负数、范围。对于多维数组，PowerShell使用类似Python的语法，即`arr[0,0]`这种形式。

### 数组的创建和访问

```powershell
$arr = 1,2,3,4,5 # 创建一维数组
$mat = New-Object 'object[,]' 2,2 # 创建二维数组
# 一般访问
$arr[1]
# 访问范围
$arr[1..4]
# 负数索引
$arr[-1]
```

### 常用操作

```powershell
$a = 1,2,3,4
# 获取数组长度
$a.Length
# 添加元素
$a += 1
# 初始化空数组
$a = @()
# 删除数组元素：PowerShell不直接支持删除数组，需要重新创建
$a = ($a[1] $a[2] $a[3])
# 约束元素类型
$a = [int[]](1,2,3)
# 复制数组
[Array]::Copy($a,$b,2) # 将前2个元素从 a 复制到 b
```

### 负数下标

类似Python，PowerShell接受负数下标。

```powershell
# 负数所以
$arr[-1]
```

### 数组切片

数组切片是集合中若干个元素的副本，可以通过下标运算符创建

```powershell
$arr[1..4]
$arr[1,3,4]
$a[-1..-3]
$a[(0,1),(1,0)] # 二维
```

### 枚举数组

除了使用下标，我们还可以使用`foreach`语句来枚举数组元素。对于多维数组，使用行优先顺序。

```powershell
$a = 10, 53, 16, -43
foreach ($elem in $a) {
    # do something with element via $e
}

foreach ($elem in -5..5) {
    # do something with element via $e
}

$a = New-Object 'int[,]' 3, 2
foreach ($elem in $a) {
    # do something with element via $e
}
```

## 哈希表

在PowerShell中，哈希表分为无序或有序两种。与数组相同，也是作为引用类型存在。

### 哈希表的创建

```powershell
$variable_name = @{ <key1> = <value1> ; < key2> = <value2> ; ..... ; < keyN> = <valueN>;}
$variable_name = [ordered] @{ < key1> = <value1> ; < key2> = <value2> ; ..... ; < keyN> = <valueN>;}
```

### 哈希表的属性

```powershell
$hash.keys
$hash.values
$hash.count
```

### 哈希表的CRUD

```powershell
# 读、改
$hash["key"] = newValue
$hash.Key = newValue
$hash[20.5] = newValue
# 增
$hash.Add(key,value)
# 删
$hash.Remove(key)
# 遍历
$hash.GetEnumerator() | Sort-Object -Property key
# 串联
$h1 += $h2
$h1 = $h1 + $h2
```
